// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/vestamart/homework/internal/app.CartRepository -o cart_repository_mock.go -n CartRepositoryMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements mm_app.CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddToCart          func(ctx context.Context, skuID int64, userID uint64, count uint16) (err error)
	funcAddToCartOrigin    string
	inspectFuncAddToCart   func(ctx context.Context, skuID int64, userID uint64, count uint16)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCartRepositoryMockAddToCart

	funcClearCart          func(ctx context.Context, userID uint64) (err error)
	funcClearCartOrigin    string
	inspectFuncClearCart   func(ctx context.Context, userID uint64)
	afterClearCartCounter  uint64
	beforeClearCartCounter uint64
	ClearCartMock          mCartRepositoryMockClearCart

	funcGetCart          func(ctx context.Context, userID uint64) (m1 map[int64]uint16, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(ctx context.Context, userID uint64)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mCartRepositoryMockGetCart

	funcRemoveFromCart          func(ctx context.Context, skuID int64, userID uint64) (err error)
	funcRemoveFromCartOrigin    string
	inspectFuncRemoveFromCart   func(ctx context.Context, skuID int64, userID uint64)
	afterRemoveFromCartCounter  uint64
	beforeRemoveFromCartCounter uint64
	RemoveFromCartMock          mCartRepositoryMockRemoveFromCart
}

// NewCartRepositoryMock returns a mock for mm_app.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCartRepositoryMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CartRepositoryMockAddToCartParams{}

	m.ClearCartMock = mCartRepositoryMockClearCart{mock: m}
	m.ClearCartMock.callArgs = []*CartRepositoryMockClearCartParams{}

	m.GetCartMock = mCartRepositoryMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*CartRepositoryMockGetCartParams{}

	m.RemoveFromCartMock = mCartRepositoryMockRemoveFromCart{mock: m}
	m.RemoveFromCartMock.callArgs = []*CartRepositoryMockRemoveFromCartParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAddToCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddToCartExpectation
	expectations       []*CartRepositoryMockAddToCartExpectation

	callArgs []*CartRepositoryMockAddToCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockAddToCartExpectation specifies expectation struct of the CartRepository.AddToCart
type CartRepositoryMockAddToCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockAddToCartParams
	paramPtrs          *CartRepositoryMockAddToCartParamPtrs
	expectationOrigins CartRepositoryMockAddToCartExpectationOrigins
	results            *CartRepositoryMockAddToCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockAddToCartParams contains parameters of the CartRepository.AddToCart
type CartRepositoryMockAddToCartParams struct {
	ctx    context.Context
	skuID  int64
	userID uint64
	count  uint16
}

// CartRepositoryMockAddToCartParamPtrs contains pointers to parameters of the CartRepository.AddToCart
type CartRepositoryMockAddToCartParamPtrs struct {
	ctx    *context.Context
	skuID  *int64
	userID *uint64
	count  *uint16
}

// CartRepositoryMockAddToCartResults contains results of the CartRepository.AddToCart
type CartRepositoryMockAddToCartResults struct {
	err error
}

// CartRepositoryMockAddToCartOrigins contains origins of expectations of the CartRepository.AddToCart
type CartRepositoryMockAddToCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originSkuID  string
	originUserID string
	originCount  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddToCart *mCartRepositoryMockAddToCart) Optional() *mCartRepositoryMockAddToCart {
	mmAddToCart.optional = true
	return mmAddToCart
}

// Expect sets up expected params for CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Expect(ctx context.Context, skuID int64, userID uint64, count uint16) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{}
	}

	if mmAddToCart.defaultExpectation.paramPtrs != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by ExpectParams functions")
	}

	mmAddToCart.defaultExpectation.params = &CartRepositoryMockAddToCartParams{ctx, skuID, userID, count}
	mmAddToCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{}
	}

	if mmAddToCart.defaultExpectation.params != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Expect")
	}

	if mmAddToCart.defaultExpectation.paramPtrs == nil {
		mmAddToCart.defaultExpectation.paramPtrs = &CartRepositoryMockAddToCartParamPtrs{}
	}
	mmAddToCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddToCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddToCart
}

// ExpectSkuIDParam2 sets up expected param skuID for CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) ExpectSkuIDParam2(skuID int64) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{}
	}

	if mmAddToCart.defaultExpectation.params != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Expect")
	}

	if mmAddToCart.defaultExpectation.paramPtrs == nil {
		mmAddToCart.defaultExpectation.paramPtrs = &CartRepositoryMockAddToCartParamPtrs{}
	}
	mmAddToCart.defaultExpectation.paramPtrs.skuID = &skuID
	mmAddToCart.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmAddToCart
}

// ExpectUserIDParam3 sets up expected param userID for CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) ExpectUserIDParam3(userID uint64) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{}
	}

	if mmAddToCart.defaultExpectation.params != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Expect")
	}

	if mmAddToCart.defaultExpectation.paramPtrs == nil {
		mmAddToCart.defaultExpectation.paramPtrs = &CartRepositoryMockAddToCartParamPtrs{}
	}
	mmAddToCart.defaultExpectation.paramPtrs.userID = &userID
	mmAddToCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddToCart
}

// ExpectCountParam4 sets up expected param count for CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) ExpectCountParam4(count uint16) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{}
	}

	if mmAddToCart.defaultExpectation.params != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Expect")
	}

	if mmAddToCart.defaultExpectation.paramPtrs == nil {
		mmAddToCart.defaultExpectation.paramPtrs = &CartRepositoryMockAddToCartParamPtrs{}
	}
	mmAddToCart.defaultExpectation.paramPtrs.count = &count
	mmAddToCart.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Inspect(f func(ctx context.Context, skuID int64, userID uint64, count uint16)) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Return(err error) *CartRepositoryMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CartRepositoryMockAddToCartResults{err}
	mmAddToCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddToCart.mock
}

// Set uses given function f to mock the CartRepository.AddToCart method
func (mmAddToCart *mCartRepositoryMockAddToCart) Set(f func(ctx context.Context, skuID int64, userID uint64, count uint16) (err error)) *CartRepositoryMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	mmAddToCart.mock.funcAddToCartOrigin = minimock.CallerInfo(1)
	return mmAddToCart.mock
}

// When sets expectation for the CartRepository.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCartRepositoryMockAddToCart) When(ctx context.Context, skuID int64, userID uint64, count uint16) *CartRepositoryMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddToCartExpectation{
		mock:               mmAddToCart.mock,
		params:             &CartRepositoryMockAddToCartParams{ctx, skuID, userID, count},
		expectationOrigins: CartRepositoryMockAddToCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddToCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddToCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddToCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.AddToCart should be invoked
func (mmAddToCart *mCartRepositoryMockAddToCart) Times(n uint64) *mCartRepositoryMockAddToCart {
	if n == 0 {
		mmAddToCart.mock.t.Fatalf("Times of CartRepositoryMock.AddToCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddToCart.expectedInvocations, n)
	mmAddToCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddToCart
}

func (mmAddToCart *mCartRepositoryMockAddToCart) invocationsDone() bool {
	if len(mmAddToCart.expectations) == 0 && mmAddToCart.defaultExpectation == nil && mmAddToCart.mock.funcAddToCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddToCart.mock.afterAddToCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddToCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddToCart implements mm_app.CartRepository
func (mmAddToCart *CartRepositoryMock) AddToCart(ctx context.Context, skuID int64, userID uint64, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	mmAddToCart.t.Helper()

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, skuID, userID, count)
	}

	mm_params := CartRepositoryMockAddToCartParams{ctx, skuID, userID, count}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, &mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_want_ptrs := mmAddToCart.AddToCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddToCartParams{ctx, skuID, userID, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddToCart.t.Errorf("CartRepositoryMock.AddToCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToCart.AddToCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmAddToCart.t.Errorf("CartRepositoryMock.AddToCart got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToCart.AddToCartMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddToCart.t.Errorf("CartRepositoryMock.AddToCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToCart.AddToCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmAddToCart.t.Errorf("CartRepositoryMock.AddToCart got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddToCart.AddToCartMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CartRepositoryMock.AddToCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddToCart.AddToCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CartRepositoryMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, skuID, userID, count)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CartRepositoryMock.AddToCart. %v %v %v %v", ctx, skuID, userID, count)
	return
}

// AddToCartAfterCounter returns a count of finished CartRepositoryMock.AddToCart invocations
func (mmAddToCart *CartRepositoryMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CartRepositoryMock.AddToCart invocations
func (mmAddToCart *CartRepositoryMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCartRepositoryMockAddToCart) Calls() []*CartRepositoryMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddToCartDone() bool {
	if m.AddToCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddToCartMock.invocationsDone()
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddToCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddToCartCounter := mm_atomic.LoadUint64(&m.afterAddToCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && afterAddToCartCounter < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.AddToCart at\n%s", m.AddToCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddToCart at\n%s with params: %#v", m.AddToCartMock.defaultExpectation.expectationOrigins.origin, *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && afterAddToCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.AddToCart at\n%s", m.funcAddToCartOrigin)
	}

	if !m.AddToCartMock.invocationsDone() && afterAddToCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.AddToCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddToCartMock.expectedInvocations), m.AddToCartMock.expectedInvocationsOrigin, afterAddToCartCounter)
	}
}

type mCartRepositoryMockClearCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockClearCartExpectation
	expectations       []*CartRepositoryMockClearCartExpectation

	callArgs []*CartRepositoryMockClearCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockClearCartExpectation specifies expectation struct of the CartRepository.ClearCart
type CartRepositoryMockClearCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockClearCartParams
	paramPtrs          *CartRepositoryMockClearCartParamPtrs
	expectationOrigins CartRepositoryMockClearCartExpectationOrigins
	results            *CartRepositoryMockClearCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockClearCartParams contains parameters of the CartRepository.ClearCart
type CartRepositoryMockClearCartParams struct {
	ctx    context.Context
	userID uint64
}

// CartRepositoryMockClearCartParamPtrs contains pointers to parameters of the CartRepository.ClearCart
type CartRepositoryMockClearCartParamPtrs struct {
	ctx    *context.Context
	userID *uint64
}

// CartRepositoryMockClearCartResults contains results of the CartRepository.ClearCart
type CartRepositoryMockClearCartResults struct {
	err error
}

// CartRepositoryMockClearCartOrigins contains origins of expectations of the CartRepository.ClearCart
type CartRepositoryMockClearCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCart *mCartRepositoryMockClearCart) Optional() *mCartRepositoryMockClearCart {
	mmClearCart.optional = true
	return mmClearCart
}

// Expect sets up expected params for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Expect(ctx context.Context, userID uint64) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.paramPtrs != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by ExpectParams functions")
	}

	mmClearCart.defaultExpectation.params = &CartRepositoryMockClearCartParams{ctx, userID}
	mmClearCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearCart.expectations {
		if minimock.Equal(e.params, mmClearCart.defaultExpectation.params) {
			mmClearCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCart.defaultExpectation.params)
		}
	}

	return mmClearCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmClearCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClearCart
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) ExpectUserIDParam2(userID uint64) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &CartRepositoryMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.userID = &userID
	mmClearCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmClearCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Inspect(f func(ctx context.Context, userID uint64)) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.inspectFuncClearCart != nil {
		mmClearCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ClearCart")
	}

	mmClearCart.mock.inspectFuncClearCart = f

	return mmClearCart
}

// Return sets up results that will be returned by CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Return(err error) *CartRepositoryMock {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{mock: mmClearCart.mock}
	}
	mmClearCart.defaultExpectation.results = &CartRepositoryMockClearCartResults{err}
	mmClearCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// Set uses given function f to mock the CartRepository.ClearCart method
func (mmClearCart *mCartRepositoryMockClearCart) Set(f func(ctx context.Context, userID uint64) (err error)) *CartRepositoryMock {
	if mmClearCart.defaultExpectation != nil {
		mmClearCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.ClearCart method")
	}

	if len(mmClearCart.expectations) > 0 {
		mmClearCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.ClearCart method")
	}

	mmClearCart.mock.funcClearCart = f
	mmClearCart.mock.funcClearCartOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// When sets expectation for the CartRepository.ClearCart which will trigger the result defined by the following
// Then helper
func (mmClearCart *mCartRepositoryMockClearCart) When(ctx context.Context, userID uint64) *CartRepositoryMockClearCartExpectation {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockClearCartExpectation{
		mock:               mmClearCart.mock,
		params:             &CartRepositoryMockClearCartParams{ctx, userID},
		expectationOrigins: CartRepositoryMockClearCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearCart.expectations = append(mmClearCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.ClearCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockClearCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockClearCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.ClearCart should be invoked
func (mmClearCart *mCartRepositoryMockClearCart) Times(n uint64) *mCartRepositoryMockClearCart {
	if n == 0 {
		mmClearCart.mock.t.Fatalf("Times of CartRepositoryMock.ClearCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCart.expectedInvocations, n)
	mmClearCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCart
}

func (mmClearCart *mCartRepositoryMockClearCart) invocationsDone() bool {
	if len(mmClearCart.expectations) == 0 && mmClearCart.defaultExpectation == nil && mmClearCart.mock.funcClearCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCart.mock.afterClearCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCart implements mm_app.CartRepository
func (mmClearCart *CartRepositoryMock) ClearCart(ctx context.Context, userID uint64) (err error) {
	mm_atomic.AddUint64(&mmClearCart.beforeClearCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCart.afterClearCartCounter, 1)

	mmClearCart.t.Helper()

	if mmClearCart.inspectFuncClearCart != nil {
		mmClearCart.inspectFuncClearCart(ctx, userID)
	}

	mm_params := CartRepositoryMockClearCartParams{ctx, userID}

	// Record call args
	mmClearCart.ClearCartMock.mutex.Lock()
	mmClearCart.ClearCartMock.callArgs = append(mmClearCart.ClearCartMock.callArgs, &mm_params)
	mmClearCart.ClearCartMock.mutex.Unlock()

	for _, e := range mmClearCart.ClearCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCart.ClearCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCart.ClearCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCart.ClearCartMock.defaultExpectation.params
		mm_want_ptrs := mmClearCart.ClearCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockClearCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCart.ClearCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCart.t.Fatal("No results are set for the CartRepositoryMock.ClearCart")
		}
		return (*mm_results).err
	}
	if mmClearCart.funcClearCart != nil {
		return mmClearCart.funcClearCart(ctx, userID)
	}
	mmClearCart.t.Fatalf("Unexpected call to CartRepositoryMock.ClearCart. %v %v", ctx, userID)
	return
}

// ClearCartAfterCounter returns a count of finished CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.afterClearCartCounter)
}

// ClearCartBeforeCounter returns a count of CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.beforeClearCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ClearCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCart *mCartRepositoryMockClearCart) Calls() []*CartRepositoryMockClearCartParams {
	mmClearCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockClearCartParams, len(mmClearCart.callArgs))
	copy(argCopy, mmClearCart.callArgs)

	mmClearCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartDone returns true if the count of the ClearCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockClearCartDone() bool {
	if m.ClearCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartMock.invocationsDone()
}

// MinimockClearCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockClearCartInspect() {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCartCounter := mm_atomic.LoadUint64(&m.afterClearCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && afterClearCartCounter < 1 {
		if m.ClearCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s", m.ClearCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s with params: %#v", m.ClearCartMock.defaultExpectation.expectationOrigins.origin, *m.ClearCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && afterClearCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.ClearCart at\n%s", m.funcClearCartOrigin)
	}

	if !m.ClearCartMock.invocationsDone() && afterClearCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.ClearCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartMock.expectedInvocations), m.ClearCartMock.expectedInvocationsOrigin, afterClearCartCounter)
	}
}

type mCartRepositoryMockGetCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartExpectation
	expectations       []*CartRepositoryMockGetCartExpectation

	callArgs []*CartRepositoryMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetCartExpectation specifies expectation struct of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetCartParams
	paramPtrs          *CartRepositoryMockGetCartParamPtrs
	expectationOrigins CartRepositoryMockGetCartExpectationOrigins
	results            *CartRepositoryMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetCartParams contains parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParams struct {
	ctx    context.Context
	userID uint64
}

// CartRepositoryMockGetCartParamPtrs contains pointers to parameters of the CartRepository.GetCart
type CartRepositoryMockGetCartParamPtrs struct {
	ctx    *context.Context
	userID *uint64
}

// CartRepositoryMockGetCartResults contains results of the CartRepository.GetCart
type CartRepositoryMockGetCartResults struct {
	m1  map[int64]uint16
	err error
}

// CartRepositoryMockGetCartOrigins contains origins of expectations of the CartRepository.GetCart
type CartRepositoryMockGetCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mCartRepositoryMockGetCart) Optional() *mCartRepositoryMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Expect(ctx context.Context, userID uint64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &CartRepositoryMockGetCartParams{ctx, userID}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCart
}

// ExpectUserIDParam2 sets up expected param userID for CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) ExpectUserIDParam2(userID uint64) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.userID = &userID
	mmGetCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Inspect(f func(ctx context.Context, userID uint64)) *mCartRepositoryMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by CartRepository.GetCart
func (mmGetCart *mCartRepositoryMockGetCart) Return(m1 map[int64]uint16, err error) *CartRepositoryMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &CartRepositoryMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &CartRepositoryMockGetCartResults{m1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the CartRepository.GetCart method
func (mmGetCart *mCartRepositoryMockGetCart) Set(f func(ctx context.Context, userID uint64) (m1 map[int64]uint16, err error)) *CartRepositoryMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the CartRepository.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mCartRepositoryMockGetCart) When(ctx context.Context, userID uint64) *CartRepositoryMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("CartRepositoryMock.GetCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &CartRepositoryMockGetCartParams{ctx, userID},
		expectationOrigins: CartRepositoryMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartExpectation) Then(m1 map[int64]uint16, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartResults{m1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetCart should be invoked
func (mmGetCart *mCartRepositoryMockGetCart) Times(n uint64) *mCartRepositoryMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of CartRepositoryMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mCartRepositoryMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements mm_app.CartRepository
func (mmGetCart *CartRepositoryMock) GetCart(ctx context.Context, userID uint64) (m1 map[int64]uint16, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(ctx, userID)
	}

	mm_params := CartRepositoryMockGetCartParams{ctx, userID}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("CartRepositoryMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the CartRepositoryMock.GetCart")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(ctx, userID)
	}
	mmGetCart.t.Fatalf("Unexpected call to CartRepositoryMock.GetCart. %v %v", ctx, userID)
	return
}

// GetCartAfterCounter returns a count of finished CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of CartRepositoryMock.GetCart invocations
func (mmGetCart *CartRepositoryMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mCartRepositoryMockGetCart) Calls() []*CartRepositoryMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

type mCartRepositoryMockRemoveFromCart struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockRemoveFromCartExpectation
	expectations       []*CartRepositoryMockRemoveFromCartExpectation

	callArgs []*CartRepositoryMockRemoveFromCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockRemoveFromCartExpectation specifies expectation struct of the CartRepository.RemoveFromCart
type CartRepositoryMockRemoveFromCartExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockRemoveFromCartParams
	paramPtrs          *CartRepositoryMockRemoveFromCartParamPtrs
	expectationOrigins CartRepositoryMockRemoveFromCartExpectationOrigins
	results            *CartRepositoryMockRemoveFromCartResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockRemoveFromCartParams contains parameters of the CartRepository.RemoveFromCart
type CartRepositoryMockRemoveFromCartParams struct {
	ctx    context.Context
	skuID  int64
	userID uint64
}

// CartRepositoryMockRemoveFromCartParamPtrs contains pointers to parameters of the CartRepository.RemoveFromCart
type CartRepositoryMockRemoveFromCartParamPtrs struct {
	ctx    *context.Context
	skuID  *int64
	userID *uint64
}

// CartRepositoryMockRemoveFromCartResults contains results of the CartRepository.RemoveFromCart
type CartRepositoryMockRemoveFromCartResults struct {
	err error
}

// CartRepositoryMockRemoveFromCartOrigins contains origins of expectations of the CartRepository.RemoveFromCart
type CartRepositoryMockRemoveFromCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originSkuID  string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) Optional() *mCartRepositoryMockRemoveFromCart {
	mmRemoveFromCart.optional = true
	return mmRemoveFromCart
}

// Expect sets up expected params for CartRepository.RemoveFromCart
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) Expect(ctx context.Context, skuID int64, userID uint64) *mCartRepositoryMockRemoveFromCart {
	if mmRemoveFromCart.mock.funcRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by Set")
	}

	if mmRemoveFromCart.defaultExpectation == nil {
		mmRemoveFromCart.defaultExpectation = &CartRepositoryMockRemoveFromCartExpectation{}
	}

	if mmRemoveFromCart.defaultExpectation.paramPtrs != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by ExpectParams functions")
	}

	mmRemoveFromCart.defaultExpectation.params = &CartRepositoryMockRemoveFromCartParams{ctx, skuID, userID}
	mmRemoveFromCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveFromCart.expectations {
		if minimock.Equal(e.params, mmRemoveFromCart.defaultExpectation.params) {
			mmRemoveFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveFromCart.defaultExpectation.params)
		}
	}

	return mmRemoveFromCart
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.RemoveFromCart
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockRemoveFromCart {
	if mmRemoveFromCart.mock.funcRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by Set")
	}

	if mmRemoveFromCart.defaultExpectation == nil {
		mmRemoveFromCart.defaultExpectation = &CartRepositoryMockRemoveFromCartExpectation{}
	}

	if mmRemoveFromCart.defaultExpectation.params != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by Expect")
	}

	if mmRemoveFromCart.defaultExpectation.paramPtrs == nil {
		mmRemoveFromCart.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveFromCartParamPtrs{}
	}
	mmRemoveFromCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveFromCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveFromCart
}

// ExpectSkuIDParam2 sets up expected param skuID for CartRepository.RemoveFromCart
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) ExpectSkuIDParam2(skuID int64) *mCartRepositoryMockRemoveFromCart {
	if mmRemoveFromCart.mock.funcRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by Set")
	}

	if mmRemoveFromCart.defaultExpectation == nil {
		mmRemoveFromCart.defaultExpectation = &CartRepositoryMockRemoveFromCartExpectation{}
	}

	if mmRemoveFromCart.defaultExpectation.params != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by Expect")
	}

	if mmRemoveFromCart.defaultExpectation.paramPtrs == nil {
		mmRemoveFromCart.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveFromCartParamPtrs{}
	}
	mmRemoveFromCart.defaultExpectation.paramPtrs.skuID = &skuID
	mmRemoveFromCart.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmRemoveFromCart
}

// ExpectUserIDParam3 sets up expected param userID for CartRepository.RemoveFromCart
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) ExpectUserIDParam3(userID uint64) *mCartRepositoryMockRemoveFromCart {
	if mmRemoveFromCart.mock.funcRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by Set")
	}

	if mmRemoveFromCart.defaultExpectation == nil {
		mmRemoveFromCart.defaultExpectation = &CartRepositoryMockRemoveFromCartExpectation{}
	}

	if mmRemoveFromCart.defaultExpectation.params != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by Expect")
	}

	if mmRemoveFromCart.defaultExpectation.paramPtrs == nil {
		mmRemoveFromCart.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveFromCartParamPtrs{}
	}
	mmRemoveFromCart.defaultExpectation.paramPtrs.userID = &userID
	mmRemoveFromCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmRemoveFromCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.RemoveFromCart
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) Inspect(f func(ctx context.Context, skuID int64, userID uint64)) *mCartRepositoryMockRemoveFromCart {
	if mmRemoveFromCart.mock.inspectFuncRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.RemoveFromCart")
	}

	mmRemoveFromCart.mock.inspectFuncRemoveFromCart = f

	return mmRemoveFromCart
}

// Return sets up results that will be returned by CartRepository.RemoveFromCart
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) Return(err error) *CartRepositoryMock {
	if mmRemoveFromCart.mock.funcRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by Set")
	}

	if mmRemoveFromCart.defaultExpectation == nil {
		mmRemoveFromCart.defaultExpectation = &CartRepositoryMockRemoveFromCartExpectation{mock: mmRemoveFromCart.mock}
	}
	mmRemoveFromCart.defaultExpectation.results = &CartRepositoryMockRemoveFromCartResults{err}
	mmRemoveFromCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveFromCart.mock
}

// Set uses given function f to mock the CartRepository.RemoveFromCart method
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) Set(f func(ctx context.Context, skuID int64, userID uint64) (err error)) *CartRepositoryMock {
	if mmRemoveFromCart.defaultExpectation != nil {
		mmRemoveFromCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.RemoveFromCart method")
	}

	if len(mmRemoveFromCart.expectations) > 0 {
		mmRemoveFromCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.RemoveFromCart method")
	}

	mmRemoveFromCart.mock.funcRemoveFromCart = f
	mmRemoveFromCart.mock.funcRemoveFromCartOrigin = minimock.CallerInfo(1)
	return mmRemoveFromCart.mock
}

// When sets expectation for the CartRepository.RemoveFromCart which will trigger the result defined by the following
// Then helper
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) When(ctx context.Context, skuID int64, userID uint64) *CartRepositoryMockRemoveFromCartExpectation {
	if mmRemoveFromCart.mock.funcRemoveFromCart != nil {
		mmRemoveFromCart.mock.t.Fatalf("CartRepositoryMock.RemoveFromCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockRemoveFromCartExpectation{
		mock:               mmRemoveFromCart.mock,
		params:             &CartRepositoryMockRemoveFromCartParams{ctx, skuID, userID},
		expectationOrigins: CartRepositoryMockRemoveFromCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveFromCart.expectations = append(mmRemoveFromCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.RemoveFromCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockRemoveFromCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockRemoveFromCartResults{err}
	return e.mock
}

// Times sets number of times CartRepository.RemoveFromCart should be invoked
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) Times(n uint64) *mCartRepositoryMockRemoveFromCart {
	if n == 0 {
		mmRemoveFromCart.mock.t.Fatalf("Times of CartRepositoryMock.RemoveFromCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveFromCart.expectedInvocations, n)
	mmRemoveFromCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveFromCart
}

func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) invocationsDone() bool {
	if len(mmRemoveFromCart.expectations) == 0 && mmRemoveFromCart.defaultExpectation == nil && mmRemoveFromCart.mock.funcRemoveFromCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveFromCart.mock.afterRemoveFromCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveFromCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveFromCart implements mm_app.CartRepository
func (mmRemoveFromCart *CartRepositoryMock) RemoveFromCart(ctx context.Context, skuID int64, userID uint64) (err error) {
	mm_atomic.AddUint64(&mmRemoveFromCart.beforeRemoveFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveFromCart.afterRemoveFromCartCounter, 1)

	mmRemoveFromCart.t.Helper()

	if mmRemoveFromCart.inspectFuncRemoveFromCart != nil {
		mmRemoveFromCart.inspectFuncRemoveFromCart(ctx, skuID, userID)
	}

	mm_params := CartRepositoryMockRemoveFromCartParams{ctx, skuID, userID}

	// Record call args
	mmRemoveFromCart.RemoveFromCartMock.mutex.Lock()
	mmRemoveFromCart.RemoveFromCartMock.callArgs = append(mmRemoveFromCart.RemoveFromCartMock.callArgs, &mm_params)
	mmRemoveFromCart.RemoveFromCartMock.mutex.Unlock()

	for _, e := range mmRemoveFromCart.RemoveFromCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveFromCart.RemoveFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockRemoveFromCartParams{ctx, skuID, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveFromCart.t.Errorf("CartRepositoryMock.RemoveFromCart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmRemoveFromCart.t.Errorf("CartRepositoryMock.RemoveFromCart got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmRemoveFromCart.t.Errorf("CartRepositoryMock.RemoveFromCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveFromCart.t.Errorf("CartRepositoryMock.RemoveFromCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveFromCart.RemoveFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveFromCart.t.Fatal("No results are set for the CartRepositoryMock.RemoveFromCart")
		}
		return (*mm_results).err
	}
	if mmRemoveFromCart.funcRemoveFromCart != nil {
		return mmRemoveFromCart.funcRemoveFromCart(ctx, skuID, userID)
	}
	mmRemoveFromCart.t.Fatalf("Unexpected call to CartRepositoryMock.RemoveFromCart. %v %v %v", ctx, skuID, userID)
	return
}

// RemoveFromCartAfterCounter returns a count of finished CartRepositoryMock.RemoveFromCart invocations
func (mmRemoveFromCart *CartRepositoryMock) RemoveFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFromCart.afterRemoveFromCartCounter)
}

// RemoveFromCartBeforeCounter returns a count of CartRepositoryMock.RemoveFromCart invocations
func (mmRemoveFromCart *CartRepositoryMock) RemoveFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveFromCart.beforeRemoveFromCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.RemoveFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveFromCart *mCartRepositoryMockRemoveFromCart) Calls() []*CartRepositoryMockRemoveFromCartParams {
	mmRemoveFromCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockRemoveFromCartParams, len(mmRemoveFromCart.callArgs))
	copy(argCopy, mmRemoveFromCart.callArgs)

	mmRemoveFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveFromCartDone returns true if the count of the RemoveFromCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockRemoveFromCartDone() bool {
	if m.RemoveFromCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveFromCartMock.invocationsDone()
}

// MinimockRemoveFromCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockRemoveFromCartInspect() {
	for _, e := range m.RemoveFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveFromCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveFromCartCounter := mm_atomic.LoadUint64(&m.afterRemoveFromCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveFromCartMock.defaultExpectation != nil && afterRemoveFromCartCounter < 1 {
		if m.RemoveFromCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveFromCart at\n%s", m.RemoveFromCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveFromCart at\n%s with params: %#v", m.RemoveFromCartMock.defaultExpectation.expectationOrigins.origin, *m.RemoveFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveFromCart != nil && afterRemoveFromCartCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.RemoveFromCart at\n%s", m.funcRemoveFromCartOrigin)
	}

	if !m.RemoveFromCartMock.invocationsDone() && afterRemoveFromCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.RemoveFromCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveFromCartMock.expectedInvocations), m.RemoveFromCartMock.expectedInvocationsOrigin, afterRemoveFromCartCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddToCartInspect()

			m.MinimockClearCartInspect()

			m.MinimockGetCartInspect()

			m.MinimockRemoveFromCartInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockClearCartDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockRemoveFromCartDone()
}
