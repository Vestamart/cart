// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/vestamart/homework/internal/app/loms.StocksStorage -o stock_repository_mock.go -n StocksStorageMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StocksStorageMock implements mm_loms.StocksStorage
type StocksStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetBySKU          func(ctx context.Context, sku uint32) (u1 uint32, err error)
	funcGetBySKUOrigin    string
	inspectFuncGetBySKU   func(ctx context.Context, sku uint32)
	afterGetBySKUCounter  uint64
	beforeGetBySKUCounter uint64
	GetBySKUMock          mStocksStorageMockGetBySKU

	funcReserve          func(ctx context.Context, sku uint32, count uint32) (err error)
	funcReserveOrigin    string
	inspectFuncReserve   func(ctx context.Context, sku uint32, count uint32)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStocksStorageMockReserve

	funcReserveCancel          func(ctx context.Context, skus map[uint32]uint32) (err error)
	funcReserveCancelOrigin    string
	inspectFuncReserveCancel   func(ctx context.Context, skus map[uint32]uint32)
	afterReserveCancelCounter  uint64
	beforeReserveCancelCounter uint64
	ReserveCancelMock          mStocksStorageMockReserveCancel

	funcReserveRemove          func(ctx context.Context, sku uint32, count uint32) (err error)
	funcReserveRemoveOrigin    string
	inspectFuncReserveRemove   func(ctx context.Context, sku uint32, count uint32)
	afterReserveRemoveCounter  uint64
	beforeReserveRemoveCounter uint64
	ReserveRemoveMock          mStocksStorageMockReserveRemove

	funcRollbackReserve          func(ctx context.Context, skus map[uint32]uint32) (err error)
	funcRollbackReserveOrigin    string
	inspectFuncRollbackReserve   func(ctx context.Context, skus map[uint32]uint32)
	afterRollbackReserveCounter  uint64
	beforeRollbackReserveCounter uint64
	RollbackReserveMock          mStocksStorageMockRollbackReserve
}

// NewStocksStorageMock returns a mock for mm_loms.StocksStorage
func NewStocksStorageMock(t minimock.Tester) *StocksStorageMock {
	m := &StocksStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetBySKUMock = mStocksStorageMockGetBySKU{mock: m}
	m.GetBySKUMock.callArgs = []*StocksStorageMockGetBySKUParams{}

	m.ReserveMock = mStocksStorageMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StocksStorageMockReserveParams{}

	m.ReserveCancelMock = mStocksStorageMockReserveCancel{mock: m}
	m.ReserveCancelMock.callArgs = []*StocksStorageMockReserveCancelParams{}

	m.ReserveRemoveMock = mStocksStorageMockReserveRemove{mock: m}
	m.ReserveRemoveMock.callArgs = []*StocksStorageMockReserveRemoveParams{}

	m.RollbackReserveMock = mStocksStorageMockRollbackReserve{mock: m}
	m.RollbackReserveMock.callArgs = []*StocksStorageMockRollbackReserveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStocksStorageMockGetBySKU struct {
	optional           bool
	mock               *StocksStorageMock
	defaultExpectation *StocksStorageMockGetBySKUExpectation
	expectations       []*StocksStorageMockGetBySKUExpectation

	callArgs []*StocksStorageMockGetBySKUParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StocksStorageMockGetBySKUExpectation specifies expectation struct of the StocksStorage.GetBySKU
type StocksStorageMockGetBySKUExpectation struct {
	mock               *StocksStorageMock
	params             *StocksStorageMockGetBySKUParams
	paramPtrs          *StocksStorageMockGetBySKUParamPtrs
	expectationOrigins StocksStorageMockGetBySKUExpectationOrigins
	results            *StocksStorageMockGetBySKUResults
	returnOrigin       string
	Counter            uint64
}

// StocksStorageMockGetBySKUParams contains parameters of the StocksStorage.GetBySKU
type StocksStorageMockGetBySKUParams struct {
	ctx context.Context
	sku uint32
}

// StocksStorageMockGetBySKUParamPtrs contains pointers to parameters of the StocksStorage.GetBySKU
type StocksStorageMockGetBySKUParamPtrs struct {
	ctx *context.Context
	sku *uint32
}

// StocksStorageMockGetBySKUResults contains results of the StocksStorage.GetBySKU
type StocksStorageMockGetBySKUResults struct {
	u1  uint32
	err error
}

// StocksStorageMockGetBySKUOrigins contains origins of expectations of the StocksStorage.GetBySKU
type StocksStorageMockGetBySKUExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBySKU *mStocksStorageMockGetBySKU) Optional() *mStocksStorageMockGetBySKU {
	mmGetBySKU.optional = true
	return mmGetBySKU
}

// Expect sets up expected params for StocksStorage.GetBySKU
func (mmGetBySKU *mStocksStorageMockGetBySKU) Expect(ctx context.Context, sku uint32) *mStocksStorageMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StocksStorageMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StocksStorageMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.paramPtrs != nil {
		mmGetBySKU.mock.t.Fatalf("StocksStorageMock.GetBySKU mock is already set by ExpectParams functions")
	}

	mmGetBySKU.defaultExpectation.params = &StocksStorageMockGetBySKUParams{ctx, sku}
	mmGetBySKU.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBySKU.expectations {
		if minimock.Equal(e.params, mmGetBySKU.defaultExpectation.params) {
			mmGetBySKU.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBySKU.defaultExpectation.params)
		}
	}

	return mmGetBySKU
}

// ExpectCtxParam1 sets up expected param ctx for StocksStorage.GetBySKU
func (mmGetBySKU *mStocksStorageMockGetBySKU) ExpectCtxParam1(ctx context.Context) *mStocksStorageMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StocksStorageMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StocksStorageMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StocksStorageMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StocksStorageMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBySKU.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBySKU
}

// ExpectSkuParam2 sets up expected param sku for StocksStorage.GetBySKU
func (mmGetBySKU *mStocksStorageMockGetBySKU) ExpectSkuParam2(sku uint32) *mStocksStorageMockGetBySKU {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StocksStorageMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StocksStorageMockGetBySKUExpectation{}
	}

	if mmGetBySKU.defaultExpectation.params != nil {
		mmGetBySKU.mock.t.Fatalf("StocksStorageMock.GetBySKU mock is already set by Expect")
	}

	if mmGetBySKU.defaultExpectation.paramPtrs == nil {
		mmGetBySKU.defaultExpectation.paramPtrs = &StocksStorageMockGetBySKUParamPtrs{}
	}
	mmGetBySKU.defaultExpectation.paramPtrs.sku = &sku
	mmGetBySKU.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmGetBySKU
}

// Inspect accepts an inspector function that has same arguments as the StocksStorage.GetBySKU
func (mmGetBySKU *mStocksStorageMockGetBySKU) Inspect(f func(ctx context.Context, sku uint32)) *mStocksStorageMockGetBySKU {
	if mmGetBySKU.mock.inspectFuncGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("Inspect function is already set for StocksStorageMock.GetBySKU")
	}

	mmGetBySKU.mock.inspectFuncGetBySKU = f

	return mmGetBySKU
}

// Return sets up results that will be returned by StocksStorage.GetBySKU
func (mmGetBySKU *mStocksStorageMockGetBySKU) Return(u1 uint32, err error) *StocksStorageMock {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StocksStorageMock.GetBySKU mock is already set by Set")
	}

	if mmGetBySKU.defaultExpectation == nil {
		mmGetBySKU.defaultExpectation = &StocksStorageMockGetBySKUExpectation{mock: mmGetBySKU.mock}
	}
	mmGetBySKU.defaultExpectation.results = &StocksStorageMockGetBySKUResults{u1, err}
	mmGetBySKU.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// Set uses given function f to mock the StocksStorage.GetBySKU method
func (mmGetBySKU *mStocksStorageMockGetBySKU) Set(f func(ctx context.Context, sku uint32) (u1 uint32, err error)) *StocksStorageMock {
	if mmGetBySKU.defaultExpectation != nil {
		mmGetBySKU.mock.t.Fatalf("Default expectation is already set for the StocksStorage.GetBySKU method")
	}

	if len(mmGetBySKU.expectations) > 0 {
		mmGetBySKU.mock.t.Fatalf("Some expectations are already set for the StocksStorage.GetBySKU method")
	}

	mmGetBySKU.mock.funcGetBySKU = f
	mmGetBySKU.mock.funcGetBySKUOrigin = minimock.CallerInfo(1)
	return mmGetBySKU.mock
}

// When sets expectation for the StocksStorage.GetBySKU which will trigger the result defined by the following
// Then helper
func (mmGetBySKU *mStocksStorageMockGetBySKU) When(ctx context.Context, sku uint32) *StocksStorageMockGetBySKUExpectation {
	if mmGetBySKU.mock.funcGetBySKU != nil {
		mmGetBySKU.mock.t.Fatalf("StocksStorageMock.GetBySKU mock is already set by Set")
	}

	expectation := &StocksStorageMockGetBySKUExpectation{
		mock:               mmGetBySKU.mock,
		params:             &StocksStorageMockGetBySKUParams{ctx, sku},
		expectationOrigins: StocksStorageMockGetBySKUExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBySKU.expectations = append(mmGetBySKU.expectations, expectation)
	return expectation
}

// Then sets up StocksStorage.GetBySKU return parameters for the expectation previously defined by the When method
func (e *StocksStorageMockGetBySKUExpectation) Then(u1 uint32, err error) *StocksStorageMock {
	e.results = &StocksStorageMockGetBySKUResults{u1, err}
	return e.mock
}

// Times sets number of times StocksStorage.GetBySKU should be invoked
func (mmGetBySKU *mStocksStorageMockGetBySKU) Times(n uint64) *mStocksStorageMockGetBySKU {
	if n == 0 {
		mmGetBySKU.mock.t.Fatalf("Times of StocksStorageMock.GetBySKU mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBySKU.expectedInvocations, n)
	mmGetBySKU.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBySKU
}

func (mmGetBySKU *mStocksStorageMockGetBySKU) invocationsDone() bool {
	if len(mmGetBySKU.expectations) == 0 && mmGetBySKU.defaultExpectation == nil && mmGetBySKU.mock.funcGetBySKU == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBySKU.mock.afterGetBySKUCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBySKU.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBySKU implements mm_loms.StocksStorage
func (mmGetBySKU *StocksStorageMock) GetBySKU(ctx context.Context, sku uint32) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetBySKU.beforeGetBySKUCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBySKU.afterGetBySKUCounter, 1)

	mmGetBySKU.t.Helper()

	if mmGetBySKU.inspectFuncGetBySKU != nil {
		mmGetBySKU.inspectFuncGetBySKU(ctx, sku)
	}

	mm_params := StocksStorageMockGetBySKUParams{ctx, sku}

	// Record call args
	mmGetBySKU.GetBySKUMock.mutex.Lock()
	mmGetBySKU.GetBySKUMock.callArgs = append(mmGetBySKU.GetBySKUMock.callArgs, &mm_params)
	mmGetBySKU.GetBySKUMock.mutex.Unlock()

	for _, e := range mmGetBySKU.GetBySKUMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetBySKU.GetBySKUMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBySKU.GetBySKUMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBySKU.GetBySKUMock.defaultExpectation.params
		mm_want_ptrs := mmGetBySKU.GetBySKUMock.defaultExpectation.paramPtrs

		mm_got := StocksStorageMockGetBySKUParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBySKU.t.Errorf("StocksStorageMock.GetBySKU got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmGetBySKU.t.Errorf("StocksStorageMock.GetBySKU got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBySKU.t.Errorf("StocksStorageMock.GetBySKU got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBySKU.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBySKU.GetBySKUMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBySKU.t.Fatal("No results are set for the StocksStorageMock.GetBySKU")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetBySKU.funcGetBySKU != nil {
		return mmGetBySKU.funcGetBySKU(ctx, sku)
	}
	mmGetBySKU.t.Fatalf("Unexpected call to StocksStorageMock.GetBySKU. %v %v", ctx, sku)
	return
}

// GetBySKUAfterCounter returns a count of finished StocksStorageMock.GetBySKU invocations
func (mmGetBySKU *StocksStorageMock) GetBySKUAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.afterGetBySKUCounter)
}

// GetBySKUBeforeCounter returns a count of StocksStorageMock.GetBySKU invocations
func (mmGetBySKU *StocksStorageMock) GetBySKUBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBySKU.beforeGetBySKUCounter)
}

// Calls returns a list of arguments used in each call to StocksStorageMock.GetBySKU.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBySKU *mStocksStorageMockGetBySKU) Calls() []*StocksStorageMockGetBySKUParams {
	mmGetBySKU.mutex.RLock()

	argCopy := make([]*StocksStorageMockGetBySKUParams, len(mmGetBySKU.callArgs))
	copy(argCopy, mmGetBySKU.callArgs)

	mmGetBySKU.mutex.RUnlock()

	return argCopy
}

// MinimockGetBySKUDone returns true if the count of the GetBySKU invocations corresponds
// the number of defined expectations
func (m *StocksStorageMock) MinimockGetBySKUDone() bool {
	if m.GetBySKUMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetBySKUMock.invocationsDone()
}

// MinimockGetBySKUInspect logs each unmet expectation
func (m *StocksStorageMock) MinimockGetBySKUInspect() {
	for _, e := range m.GetBySKUMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksStorageMock.GetBySKU at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetBySKUCounter := mm_atomic.LoadUint64(&m.afterGetBySKUCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetBySKUMock.defaultExpectation != nil && afterGetBySKUCounter < 1 {
		if m.GetBySKUMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StocksStorageMock.GetBySKU at\n%s", m.GetBySKUMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StocksStorageMock.GetBySKU at\n%s with params: %#v", m.GetBySKUMock.defaultExpectation.expectationOrigins.origin, *m.GetBySKUMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBySKU != nil && afterGetBySKUCounter < 1 {
		m.t.Errorf("Expected call to StocksStorageMock.GetBySKU at\n%s", m.funcGetBySKUOrigin)
	}

	if !m.GetBySKUMock.invocationsDone() && afterGetBySKUCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksStorageMock.GetBySKU at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetBySKUMock.expectedInvocations), m.GetBySKUMock.expectedInvocationsOrigin, afterGetBySKUCounter)
	}
}

type mStocksStorageMockReserve struct {
	optional           bool
	mock               *StocksStorageMock
	defaultExpectation *StocksStorageMockReserveExpectation
	expectations       []*StocksStorageMockReserveExpectation

	callArgs []*StocksStorageMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StocksStorageMockReserveExpectation specifies expectation struct of the StocksStorage.Reserve
type StocksStorageMockReserveExpectation struct {
	mock               *StocksStorageMock
	params             *StocksStorageMockReserveParams
	paramPtrs          *StocksStorageMockReserveParamPtrs
	expectationOrigins StocksStorageMockReserveExpectationOrigins
	results            *StocksStorageMockReserveResults
	returnOrigin       string
	Counter            uint64
}

// StocksStorageMockReserveParams contains parameters of the StocksStorage.Reserve
type StocksStorageMockReserveParams struct {
	ctx   context.Context
	sku   uint32
	count uint32
}

// StocksStorageMockReserveParamPtrs contains pointers to parameters of the StocksStorage.Reserve
type StocksStorageMockReserveParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint32
}

// StocksStorageMockReserveResults contains results of the StocksStorage.Reserve
type StocksStorageMockReserveResults struct {
	err error
}

// StocksStorageMockReserveOrigins contains origins of expectations of the StocksStorage.Reserve
type StocksStorageMockReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mStocksStorageMockReserve) Optional() *mStocksStorageMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for StocksStorage.Reserve
func (mmReserve *mStocksStorageMockReserve) Expect(ctx context.Context, sku uint32, count uint32) *mStocksStorageMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksStorageMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &StocksStorageMockReserveParams{ctx, sku, count}
	mmReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for StocksStorage.Reserve
func (mmReserve *mStocksStorageMockReserve) ExpectCtxParam1(ctx context.Context) *mStocksStorageMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksStorageMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StocksStorageMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectSkuParam2 sets up expected param sku for StocksStorage.Reserve
func (mmReserve *mStocksStorageMockReserve) ExpectSkuParam2(sku uint32) *mStocksStorageMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksStorageMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StocksStorageMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.sku = &sku
	mmReserve.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectCountParam3 sets up expected param count for StocksStorage.Reserve
func (mmReserve *mStocksStorageMockReserve) ExpectCountParam3(count uint32) *mStocksStorageMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksStorageMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StocksStorageMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.count = &count
	mmReserve.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the StocksStorage.Reserve
func (mmReserve *mStocksStorageMockReserve) Inspect(f func(ctx context.Context, sku uint32, count uint32)) *mStocksStorageMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StocksStorageMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by StocksStorage.Reserve
func (mmReserve *mStocksStorageMockReserve) Return(err error) *StocksStorageMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksStorageMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StocksStorageMockReserveResults{err}
	mmReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// Set uses given function f to mock the StocksStorage.Reserve method
func (mmReserve *mStocksStorageMockReserve) Set(f func(ctx context.Context, sku uint32, count uint32) (err error)) *StocksStorageMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the StocksStorage.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the StocksStorage.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	mmReserve.mock.funcReserveOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// When sets expectation for the StocksStorage.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStocksStorageMockReserve) When(ctx context.Context, sku uint32, count uint32) *StocksStorageMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksStorageMock.Reserve mock is already set by Set")
	}

	expectation := &StocksStorageMockReserveExpectation{
		mock:               mmReserve.mock,
		params:             &StocksStorageMockReserveParams{ctx, sku, count},
		expectationOrigins: StocksStorageMockReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up StocksStorage.Reserve return parameters for the expectation previously defined by the When method
func (e *StocksStorageMockReserveExpectation) Then(err error) *StocksStorageMock {
	e.results = &StocksStorageMockReserveResults{err}
	return e.mock
}

// Times sets number of times StocksStorage.Reserve should be invoked
func (mmReserve *mStocksStorageMockReserve) Times(n uint64) *mStocksStorageMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of StocksStorageMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	mmReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserve
}

func (mmReserve *mStocksStorageMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements mm_loms.StocksStorage
func (mmReserve *StocksStorageMock) Reserve(ctx context.Context, sku uint32, count uint32) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	mmReserve.t.Helper()

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, sku, count)
	}

	mm_params := StocksStorageMockReserveParams{ctx, sku, count}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := StocksStorageMockReserveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("StocksStorageMock.Reserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmReserve.t.Errorf("StocksStorageMock.Reserve got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmReserve.t.Errorf("StocksStorageMock.Reserve got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StocksStorageMock.Reserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserve.ReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StocksStorageMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, sku, count)
	}
	mmReserve.t.Fatalf("Unexpected call to StocksStorageMock.Reserve. %v %v %v", ctx, sku, count)
	return
}

// ReserveAfterCounter returns a count of finished StocksStorageMock.Reserve invocations
func (mmReserve *StocksStorageMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StocksStorageMock.Reserve invocations
func (mmReserve *StocksStorageMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StocksStorageMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStocksStorageMockReserve) Calls() []*StocksStorageMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StocksStorageMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StocksStorageMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *StocksStorageMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksStorageMock.Reserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StocksStorageMock.Reserve at\n%s", m.ReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StocksStorageMock.Reserve at\n%s with params: %#v", m.ReserveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Errorf("Expected call to StocksStorageMock.Reserve at\n%s", m.funcReserveOrigin)
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksStorageMock.Reserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), m.ReserveMock.expectedInvocationsOrigin, afterReserveCounter)
	}
}

type mStocksStorageMockReserveCancel struct {
	optional           bool
	mock               *StocksStorageMock
	defaultExpectation *StocksStorageMockReserveCancelExpectation
	expectations       []*StocksStorageMockReserveCancelExpectation

	callArgs []*StocksStorageMockReserveCancelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StocksStorageMockReserveCancelExpectation specifies expectation struct of the StocksStorage.ReserveCancel
type StocksStorageMockReserveCancelExpectation struct {
	mock               *StocksStorageMock
	params             *StocksStorageMockReserveCancelParams
	paramPtrs          *StocksStorageMockReserveCancelParamPtrs
	expectationOrigins StocksStorageMockReserveCancelExpectationOrigins
	results            *StocksStorageMockReserveCancelResults
	returnOrigin       string
	Counter            uint64
}

// StocksStorageMockReserveCancelParams contains parameters of the StocksStorage.ReserveCancel
type StocksStorageMockReserveCancelParams struct {
	ctx  context.Context
	skus map[uint32]uint32
}

// StocksStorageMockReserveCancelParamPtrs contains pointers to parameters of the StocksStorage.ReserveCancel
type StocksStorageMockReserveCancelParamPtrs struct {
	ctx  *context.Context
	skus *map[uint32]uint32
}

// StocksStorageMockReserveCancelResults contains results of the StocksStorage.ReserveCancel
type StocksStorageMockReserveCancelResults struct {
	err error
}

// StocksStorageMockReserveCancelOrigins contains origins of expectations of the StocksStorage.ReserveCancel
type StocksStorageMockReserveCancelExpectationOrigins struct {
	origin     string
	originCtx  string
	originSkus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveCancel *mStocksStorageMockReserveCancel) Optional() *mStocksStorageMockReserveCancel {
	mmReserveCancel.optional = true
	return mmReserveCancel
}

// Expect sets up expected params for StocksStorage.ReserveCancel
func (mmReserveCancel *mStocksStorageMockReserveCancel) Expect(ctx context.Context, skus map[uint32]uint32) *mStocksStorageMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StocksStorageMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StocksStorageMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.paramPtrs != nil {
		mmReserveCancel.mock.t.Fatalf("StocksStorageMock.ReserveCancel mock is already set by ExpectParams functions")
	}

	mmReserveCancel.defaultExpectation.params = &StocksStorageMockReserveCancelParams{ctx, skus}
	mmReserveCancel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveCancel.expectations {
		if minimock.Equal(e.params, mmReserveCancel.defaultExpectation.params) {
			mmReserveCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveCancel.defaultExpectation.params)
		}
	}

	return mmReserveCancel
}

// ExpectCtxParam1 sets up expected param ctx for StocksStorage.ReserveCancel
func (mmReserveCancel *mStocksStorageMockReserveCancel) ExpectCtxParam1(ctx context.Context) *mStocksStorageMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StocksStorageMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StocksStorageMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StocksStorageMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StocksStorageMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveCancel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveCancel
}

// ExpectSkusParam2 sets up expected param skus for StocksStorage.ReserveCancel
func (mmReserveCancel *mStocksStorageMockReserveCancel) ExpectSkusParam2(skus map[uint32]uint32) *mStocksStorageMockReserveCancel {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StocksStorageMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StocksStorageMockReserveCancelExpectation{}
	}

	if mmReserveCancel.defaultExpectation.params != nil {
		mmReserveCancel.mock.t.Fatalf("StocksStorageMock.ReserveCancel mock is already set by Expect")
	}

	if mmReserveCancel.defaultExpectation.paramPtrs == nil {
		mmReserveCancel.defaultExpectation.paramPtrs = &StocksStorageMockReserveCancelParamPtrs{}
	}
	mmReserveCancel.defaultExpectation.paramPtrs.skus = &skus
	mmReserveCancel.defaultExpectation.expectationOrigins.originSkus = minimock.CallerInfo(1)

	return mmReserveCancel
}

// Inspect accepts an inspector function that has same arguments as the StocksStorage.ReserveCancel
func (mmReserveCancel *mStocksStorageMockReserveCancel) Inspect(f func(ctx context.Context, skus map[uint32]uint32)) *mStocksStorageMockReserveCancel {
	if mmReserveCancel.mock.inspectFuncReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("Inspect function is already set for StocksStorageMock.ReserveCancel")
	}

	mmReserveCancel.mock.inspectFuncReserveCancel = f

	return mmReserveCancel
}

// Return sets up results that will be returned by StocksStorage.ReserveCancel
func (mmReserveCancel *mStocksStorageMockReserveCancel) Return(err error) *StocksStorageMock {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StocksStorageMock.ReserveCancel mock is already set by Set")
	}

	if mmReserveCancel.defaultExpectation == nil {
		mmReserveCancel.defaultExpectation = &StocksStorageMockReserveCancelExpectation{mock: mmReserveCancel.mock}
	}
	mmReserveCancel.defaultExpectation.results = &StocksStorageMockReserveCancelResults{err}
	mmReserveCancel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// Set uses given function f to mock the StocksStorage.ReserveCancel method
func (mmReserveCancel *mStocksStorageMockReserveCancel) Set(f func(ctx context.Context, skus map[uint32]uint32) (err error)) *StocksStorageMock {
	if mmReserveCancel.defaultExpectation != nil {
		mmReserveCancel.mock.t.Fatalf("Default expectation is already set for the StocksStorage.ReserveCancel method")
	}

	if len(mmReserveCancel.expectations) > 0 {
		mmReserveCancel.mock.t.Fatalf("Some expectations are already set for the StocksStorage.ReserveCancel method")
	}

	mmReserveCancel.mock.funcReserveCancel = f
	mmReserveCancel.mock.funcReserveCancelOrigin = minimock.CallerInfo(1)
	return mmReserveCancel.mock
}

// When sets expectation for the StocksStorage.ReserveCancel which will trigger the result defined by the following
// Then helper
func (mmReserveCancel *mStocksStorageMockReserveCancel) When(ctx context.Context, skus map[uint32]uint32) *StocksStorageMockReserveCancelExpectation {
	if mmReserveCancel.mock.funcReserveCancel != nil {
		mmReserveCancel.mock.t.Fatalf("StocksStorageMock.ReserveCancel mock is already set by Set")
	}

	expectation := &StocksStorageMockReserveCancelExpectation{
		mock:               mmReserveCancel.mock,
		params:             &StocksStorageMockReserveCancelParams{ctx, skus},
		expectationOrigins: StocksStorageMockReserveCancelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveCancel.expectations = append(mmReserveCancel.expectations, expectation)
	return expectation
}

// Then sets up StocksStorage.ReserveCancel return parameters for the expectation previously defined by the When method
func (e *StocksStorageMockReserveCancelExpectation) Then(err error) *StocksStorageMock {
	e.results = &StocksStorageMockReserveCancelResults{err}
	return e.mock
}

// Times sets number of times StocksStorage.ReserveCancel should be invoked
func (mmReserveCancel *mStocksStorageMockReserveCancel) Times(n uint64) *mStocksStorageMockReserveCancel {
	if n == 0 {
		mmReserveCancel.mock.t.Fatalf("Times of StocksStorageMock.ReserveCancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveCancel.expectedInvocations, n)
	mmReserveCancel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveCancel
}

func (mmReserveCancel *mStocksStorageMockReserveCancel) invocationsDone() bool {
	if len(mmReserveCancel.expectations) == 0 && mmReserveCancel.defaultExpectation == nil && mmReserveCancel.mock.funcReserveCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveCancel.mock.afterReserveCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveCancel implements mm_loms.StocksStorage
func (mmReserveCancel *StocksStorageMock) ReserveCancel(ctx context.Context, skus map[uint32]uint32) (err error) {
	mm_atomic.AddUint64(&mmReserveCancel.beforeReserveCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveCancel.afterReserveCancelCounter, 1)

	mmReserveCancel.t.Helper()

	if mmReserveCancel.inspectFuncReserveCancel != nil {
		mmReserveCancel.inspectFuncReserveCancel(ctx, skus)
	}

	mm_params := StocksStorageMockReserveCancelParams{ctx, skus}

	// Record call args
	mmReserveCancel.ReserveCancelMock.mutex.Lock()
	mmReserveCancel.ReserveCancelMock.callArgs = append(mmReserveCancel.ReserveCancelMock.callArgs, &mm_params)
	mmReserveCancel.ReserveCancelMock.mutex.Unlock()

	for _, e := range mmReserveCancel.ReserveCancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveCancel.ReserveCancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveCancel.ReserveCancelMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveCancel.ReserveCancelMock.defaultExpectation.params
		mm_want_ptrs := mmReserveCancel.ReserveCancelMock.defaultExpectation.paramPtrs

		mm_got := StocksStorageMockReserveCancelParams{ctx, skus}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveCancel.t.Errorf("StocksStorageMock.ReserveCancel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skus != nil && !minimock.Equal(*mm_want_ptrs.skus, mm_got.skus) {
				mmReserveCancel.t.Errorf("StocksStorageMock.ReserveCancel got unexpected parameter skus, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.originSkus, *mm_want_ptrs.skus, mm_got.skus, minimock.Diff(*mm_want_ptrs.skus, mm_got.skus))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveCancel.t.Errorf("StocksStorageMock.ReserveCancel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveCancel.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveCancel.ReserveCancelMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveCancel.t.Fatal("No results are set for the StocksStorageMock.ReserveCancel")
		}
		return (*mm_results).err
	}
	if mmReserveCancel.funcReserveCancel != nil {
		return mmReserveCancel.funcReserveCancel(ctx, skus)
	}
	mmReserveCancel.t.Fatalf("Unexpected call to StocksStorageMock.ReserveCancel. %v %v", ctx, skus)
	return
}

// ReserveCancelAfterCounter returns a count of finished StocksStorageMock.ReserveCancel invocations
func (mmReserveCancel *StocksStorageMock) ReserveCancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.afterReserveCancelCounter)
}

// ReserveCancelBeforeCounter returns a count of StocksStorageMock.ReserveCancel invocations
func (mmReserveCancel *StocksStorageMock) ReserveCancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveCancel.beforeReserveCancelCounter)
}

// Calls returns a list of arguments used in each call to StocksStorageMock.ReserveCancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveCancel *mStocksStorageMockReserveCancel) Calls() []*StocksStorageMockReserveCancelParams {
	mmReserveCancel.mutex.RLock()

	argCopy := make([]*StocksStorageMockReserveCancelParams, len(mmReserveCancel.callArgs))
	copy(argCopy, mmReserveCancel.callArgs)

	mmReserveCancel.mutex.RUnlock()

	return argCopy
}

// MinimockReserveCancelDone returns true if the count of the ReserveCancel invocations corresponds
// the number of defined expectations
func (m *StocksStorageMock) MinimockReserveCancelDone() bool {
	if m.ReserveCancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveCancelMock.invocationsDone()
}

// MinimockReserveCancelInspect logs each unmet expectation
func (m *StocksStorageMock) MinimockReserveCancelInspect() {
	for _, e := range m.ReserveCancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksStorageMock.ReserveCancel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCancelCounter := mm_atomic.LoadUint64(&m.afterReserveCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveCancelMock.defaultExpectation != nil && afterReserveCancelCounter < 1 {
		if m.ReserveCancelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StocksStorageMock.ReserveCancel at\n%s", m.ReserveCancelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StocksStorageMock.ReserveCancel at\n%s with params: %#v", m.ReserveCancelMock.defaultExpectation.expectationOrigins.origin, *m.ReserveCancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveCancel != nil && afterReserveCancelCounter < 1 {
		m.t.Errorf("Expected call to StocksStorageMock.ReserveCancel at\n%s", m.funcReserveCancelOrigin)
	}

	if !m.ReserveCancelMock.invocationsDone() && afterReserveCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksStorageMock.ReserveCancel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveCancelMock.expectedInvocations), m.ReserveCancelMock.expectedInvocationsOrigin, afterReserveCancelCounter)
	}
}

type mStocksStorageMockReserveRemove struct {
	optional           bool
	mock               *StocksStorageMock
	defaultExpectation *StocksStorageMockReserveRemoveExpectation
	expectations       []*StocksStorageMockReserveRemoveExpectation

	callArgs []*StocksStorageMockReserveRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StocksStorageMockReserveRemoveExpectation specifies expectation struct of the StocksStorage.ReserveRemove
type StocksStorageMockReserveRemoveExpectation struct {
	mock               *StocksStorageMock
	params             *StocksStorageMockReserveRemoveParams
	paramPtrs          *StocksStorageMockReserveRemoveParamPtrs
	expectationOrigins StocksStorageMockReserveRemoveExpectationOrigins
	results            *StocksStorageMockReserveRemoveResults
	returnOrigin       string
	Counter            uint64
}

// StocksStorageMockReserveRemoveParams contains parameters of the StocksStorage.ReserveRemove
type StocksStorageMockReserveRemoveParams struct {
	ctx   context.Context
	sku   uint32
	count uint32
}

// StocksStorageMockReserveRemoveParamPtrs contains pointers to parameters of the StocksStorage.ReserveRemove
type StocksStorageMockReserveRemoveParamPtrs struct {
	ctx   *context.Context
	sku   *uint32
	count *uint32
}

// StocksStorageMockReserveRemoveResults contains results of the StocksStorage.ReserveRemove
type StocksStorageMockReserveRemoveResults struct {
	err error
}

// StocksStorageMockReserveRemoveOrigins contains origins of expectations of the StocksStorage.ReserveRemove
type StocksStorageMockReserveRemoveExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserveRemove *mStocksStorageMockReserveRemove) Optional() *mStocksStorageMockReserveRemove {
	mmReserveRemove.optional = true
	return mmReserveRemove
}

// Expect sets up expected params for StocksStorage.ReserveRemove
func (mmReserveRemove *mStocksStorageMockReserveRemove) Expect(ctx context.Context, sku uint32, count uint32) *mStocksStorageMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StocksStorageMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.paramPtrs != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by ExpectParams functions")
	}

	mmReserveRemove.defaultExpectation.params = &StocksStorageMockReserveRemoveParams{ctx, sku, count}
	mmReserveRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserveRemove.expectations {
		if minimock.Equal(e.params, mmReserveRemove.defaultExpectation.params) {
			mmReserveRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveRemove.defaultExpectation.params)
		}
	}

	return mmReserveRemove
}

// ExpectCtxParam1 sets up expected param ctx for StocksStorage.ReserveRemove
func (mmReserveRemove *mStocksStorageMockReserveRemove) ExpectCtxParam1(ctx context.Context) *mStocksStorageMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StocksStorageMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StocksStorageMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserveRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectSkuParam2 sets up expected param sku for StocksStorage.ReserveRemove
func (mmReserveRemove *mStocksStorageMockReserveRemove) ExpectSkuParam2(sku uint32) *mStocksStorageMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StocksStorageMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StocksStorageMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.sku = &sku
	mmReserveRemove.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmReserveRemove
}

// ExpectCountParam3 sets up expected param count for StocksStorage.ReserveRemove
func (mmReserveRemove *mStocksStorageMockReserveRemove) ExpectCountParam3(count uint32) *mStocksStorageMockReserveRemove {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StocksStorageMockReserveRemoveExpectation{}
	}

	if mmReserveRemove.defaultExpectation.params != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by Expect")
	}

	if mmReserveRemove.defaultExpectation.paramPtrs == nil {
		mmReserveRemove.defaultExpectation.paramPtrs = &StocksStorageMockReserveRemoveParamPtrs{}
	}
	mmReserveRemove.defaultExpectation.paramPtrs.count = &count
	mmReserveRemove.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmReserveRemove
}

// Inspect accepts an inspector function that has same arguments as the StocksStorage.ReserveRemove
func (mmReserveRemove *mStocksStorageMockReserveRemove) Inspect(f func(ctx context.Context, sku uint32, count uint32)) *mStocksStorageMockReserveRemove {
	if mmReserveRemove.mock.inspectFuncReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("Inspect function is already set for StocksStorageMock.ReserveRemove")
	}

	mmReserveRemove.mock.inspectFuncReserveRemove = f

	return mmReserveRemove
}

// Return sets up results that will be returned by StocksStorage.ReserveRemove
func (mmReserveRemove *mStocksStorageMockReserveRemove) Return(err error) *StocksStorageMock {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by Set")
	}

	if mmReserveRemove.defaultExpectation == nil {
		mmReserveRemove.defaultExpectation = &StocksStorageMockReserveRemoveExpectation{mock: mmReserveRemove.mock}
	}
	mmReserveRemove.defaultExpectation.results = &StocksStorageMockReserveRemoveResults{err}
	mmReserveRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// Set uses given function f to mock the StocksStorage.ReserveRemove method
func (mmReserveRemove *mStocksStorageMockReserveRemove) Set(f func(ctx context.Context, sku uint32, count uint32) (err error)) *StocksStorageMock {
	if mmReserveRemove.defaultExpectation != nil {
		mmReserveRemove.mock.t.Fatalf("Default expectation is already set for the StocksStorage.ReserveRemove method")
	}

	if len(mmReserveRemove.expectations) > 0 {
		mmReserveRemove.mock.t.Fatalf("Some expectations are already set for the StocksStorage.ReserveRemove method")
	}

	mmReserveRemove.mock.funcReserveRemove = f
	mmReserveRemove.mock.funcReserveRemoveOrigin = minimock.CallerInfo(1)
	return mmReserveRemove.mock
}

// When sets expectation for the StocksStorage.ReserveRemove which will trigger the result defined by the following
// Then helper
func (mmReserveRemove *mStocksStorageMockReserveRemove) When(ctx context.Context, sku uint32, count uint32) *StocksStorageMockReserveRemoveExpectation {
	if mmReserveRemove.mock.funcReserveRemove != nil {
		mmReserveRemove.mock.t.Fatalf("StocksStorageMock.ReserveRemove mock is already set by Set")
	}

	expectation := &StocksStorageMockReserveRemoveExpectation{
		mock:               mmReserveRemove.mock,
		params:             &StocksStorageMockReserveRemoveParams{ctx, sku, count},
		expectationOrigins: StocksStorageMockReserveRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserveRemove.expectations = append(mmReserveRemove.expectations, expectation)
	return expectation
}

// Then sets up StocksStorage.ReserveRemove return parameters for the expectation previously defined by the When method
func (e *StocksStorageMockReserveRemoveExpectation) Then(err error) *StocksStorageMock {
	e.results = &StocksStorageMockReserveRemoveResults{err}
	return e.mock
}

// Times sets number of times StocksStorage.ReserveRemove should be invoked
func (mmReserveRemove *mStocksStorageMockReserveRemove) Times(n uint64) *mStocksStorageMockReserveRemove {
	if n == 0 {
		mmReserveRemove.mock.t.Fatalf("Times of StocksStorageMock.ReserveRemove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserveRemove.expectedInvocations, n)
	mmReserveRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserveRemove
}

func (mmReserveRemove *mStocksStorageMockReserveRemove) invocationsDone() bool {
	if len(mmReserveRemove.expectations) == 0 && mmReserveRemove.defaultExpectation == nil && mmReserveRemove.mock.funcReserveRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserveRemove.mock.afterReserveRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserveRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReserveRemove implements mm_loms.StocksStorage
func (mmReserveRemove *StocksStorageMock) ReserveRemove(ctx context.Context, sku uint32, count uint32) (err error) {
	mm_atomic.AddUint64(&mmReserveRemove.beforeReserveRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveRemove.afterReserveRemoveCounter, 1)

	mmReserveRemove.t.Helper()

	if mmReserveRemove.inspectFuncReserveRemove != nil {
		mmReserveRemove.inspectFuncReserveRemove(ctx, sku, count)
	}

	mm_params := StocksStorageMockReserveRemoveParams{ctx, sku, count}

	// Record call args
	mmReserveRemove.ReserveRemoveMock.mutex.Lock()
	mmReserveRemove.ReserveRemoveMock.callArgs = append(mmReserveRemove.ReserveRemoveMock.callArgs, &mm_params)
	mmReserveRemove.ReserveRemoveMock.mutex.Unlock()

	for _, e := range mmReserveRemove.ReserveRemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserveRemove.ReserveRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveRemove.ReserveRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveRemove.ReserveRemoveMock.defaultExpectation.params
		mm_want_ptrs := mmReserveRemove.ReserveRemoveMock.defaultExpectation.paramPtrs

		mm_got := StocksStorageMockReserveRemoveParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserveRemove.t.Errorf("StocksStorageMock.ReserveRemove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmReserveRemove.t.Errorf("StocksStorageMock.ReserveRemove got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmReserveRemove.t.Errorf("StocksStorageMock.ReserveRemove got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveRemove.t.Errorf("StocksStorageMock.ReserveRemove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserveRemove.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveRemove.ReserveRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveRemove.t.Fatal("No results are set for the StocksStorageMock.ReserveRemove")
		}
		return (*mm_results).err
	}
	if mmReserveRemove.funcReserveRemove != nil {
		return mmReserveRemove.funcReserveRemove(ctx, sku, count)
	}
	mmReserveRemove.t.Fatalf("Unexpected call to StocksStorageMock.ReserveRemove. %v %v %v", ctx, sku, count)
	return
}

// ReserveRemoveAfterCounter returns a count of finished StocksStorageMock.ReserveRemove invocations
func (mmReserveRemove *StocksStorageMock) ReserveRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.afterReserveRemoveCounter)
}

// ReserveRemoveBeforeCounter returns a count of StocksStorageMock.ReserveRemove invocations
func (mmReserveRemove *StocksStorageMock) ReserveRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveRemove.beforeReserveRemoveCounter)
}

// Calls returns a list of arguments used in each call to StocksStorageMock.ReserveRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveRemove *mStocksStorageMockReserveRemove) Calls() []*StocksStorageMockReserveRemoveParams {
	mmReserveRemove.mutex.RLock()

	argCopy := make([]*StocksStorageMockReserveRemoveParams, len(mmReserveRemove.callArgs))
	copy(argCopy, mmReserveRemove.callArgs)

	mmReserveRemove.mutex.RUnlock()

	return argCopy
}

// MinimockReserveRemoveDone returns true if the count of the ReserveRemove invocations corresponds
// the number of defined expectations
func (m *StocksStorageMock) MinimockReserveRemoveDone() bool {
	if m.ReserveRemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveRemoveMock.invocationsDone()
}

// MinimockReserveRemoveInspect logs each unmet expectation
func (m *StocksStorageMock) MinimockReserveRemoveInspect() {
	for _, e := range m.ReserveRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksStorageMock.ReserveRemove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveRemoveCounter := mm_atomic.LoadUint64(&m.afterReserveRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveRemoveMock.defaultExpectation != nil && afterReserveRemoveCounter < 1 {
		if m.ReserveRemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StocksStorageMock.ReserveRemove at\n%s", m.ReserveRemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StocksStorageMock.ReserveRemove at\n%s with params: %#v", m.ReserveRemoveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveRemove != nil && afterReserveRemoveCounter < 1 {
		m.t.Errorf("Expected call to StocksStorageMock.ReserveRemove at\n%s", m.funcReserveRemoveOrigin)
	}

	if !m.ReserveRemoveMock.invocationsDone() && afterReserveRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksStorageMock.ReserveRemove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveRemoveMock.expectedInvocations), m.ReserveRemoveMock.expectedInvocationsOrigin, afterReserveRemoveCounter)
	}
}

type mStocksStorageMockRollbackReserve struct {
	optional           bool
	mock               *StocksStorageMock
	defaultExpectation *StocksStorageMockRollbackReserveExpectation
	expectations       []*StocksStorageMockRollbackReserveExpectation

	callArgs []*StocksStorageMockRollbackReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StocksStorageMockRollbackReserveExpectation specifies expectation struct of the StocksStorage.RollbackReserve
type StocksStorageMockRollbackReserveExpectation struct {
	mock               *StocksStorageMock
	params             *StocksStorageMockRollbackReserveParams
	paramPtrs          *StocksStorageMockRollbackReserveParamPtrs
	expectationOrigins StocksStorageMockRollbackReserveExpectationOrigins
	results            *StocksStorageMockRollbackReserveResults
	returnOrigin       string
	Counter            uint64
}

// StocksStorageMockRollbackReserveParams contains parameters of the StocksStorage.RollbackReserve
type StocksStorageMockRollbackReserveParams struct {
	ctx  context.Context
	skus map[uint32]uint32
}

// StocksStorageMockRollbackReserveParamPtrs contains pointers to parameters of the StocksStorage.RollbackReserve
type StocksStorageMockRollbackReserveParamPtrs struct {
	ctx  *context.Context
	skus *map[uint32]uint32
}

// StocksStorageMockRollbackReserveResults contains results of the StocksStorage.RollbackReserve
type StocksStorageMockRollbackReserveResults struct {
	err error
}

// StocksStorageMockRollbackReserveOrigins contains origins of expectations of the StocksStorage.RollbackReserve
type StocksStorageMockRollbackReserveExpectationOrigins struct {
	origin     string
	originCtx  string
	originSkus string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) Optional() *mStocksStorageMockRollbackReserve {
	mmRollbackReserve.optional = true
	return mmRollbackReserve
}

// Expect sets up expected params for StocksStorage.RollbackReserve
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) Expect(ctx context.Context, skus map[uint32]uint32) *mStocksStorageMockRollbackReserve {
	if mmRollbackReserve.mock.funcRollbackReserve != nil {
		mmRollbackReserve.mock.t.Fatalf("StocksStorageMock.RollbackReserve mock is already set by Set")
	}

	if mmRollbackReserve.defaultExpectation == nil {
		mmRollbackReserve.defaultExpectation = &StocksStorageMockRollbackReserveExpectation{}
	}

	if mmRollbackReserve.defaultExpectation.paramPtrs != nil {
		mmRollbackReserve.mock.t.Fatalf("StocksStorageMock.RollbackReserve mock is already set by ExpectParams functions")
	}

	mmRollbackReserve.defaultExpectation.params = &StocksStorageMockRollbackReserveParams{ctx, skus}
	mmRollbackReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRollbackReserve.expectations {
		if minimock.Equal(e.params, mmRollbackReserve.defaultExpectation.params) {
			mmRollbackReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRollbackReserve.defaultExpectation.params)
		}
	}

	return mmRollbackReserve
}

// ExpectCtxParam1 sets up expected param ctx for StocksStorage.RollbackReserve
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) ExpectCtxParam1(ctx context.Context) *mStocksStorageMockRollbackReserve {
	if mmRollbackReserve.mock.funcRollbackReserve != nil {
		mmRollbackReserve.mock.t.Fatalf("StocksStorageMock.RollbackReserve mock is already set by Set")
	}

	if mmRollbackReserve.defaultExpectation == nil {
		mmRollbackReserve.defaultExpectation = &StocksStorageMockRollbackReserveExpectation{}
	}

	if mmRollbackReserve.defaultExpectation.params != nil {
		mmRollbackReserve.mock.t.Fatalf("StocksStorageMock.RollbackReserve mock is already set by Expect")
	}

	if mmRollbackReserve.defaultExpectation.paramPtrs == nil {
		mmRollbackReserve.defaultExpectation.paramPtrs = &StocksStorageMockRollbackReserveParamPtrs{}
	}
	mmRollbackReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmRollbackReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRollbackReserve
}

// ExpectSkusParam2 sets up expected param skus for StocksStorage.RollbackReserve
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) ExpectSkusParam2(skus map[uint32]uint32) *mStocksStorageMockRollbackReserve {
	if mmRollbackReserve.mock.funcRollbackReserve != nil {
		mmRollbackReserve.mock.t.Fatalf("StocksStorageMock.RollbackReserve mock is already set by Set")
	}

	if mmRollbackReserve.defaultExpectation == nil {
		mmRollbackReserve.defaultExpectation = &StocksStorageMockRollbackReserveExpectation{}
	}

	if mmRollbackReserve.defaultExpectation.params != nil {
		mmRollbackReserve.mock.t.Fatalf("StocksStorageMock.RollbackReserve mock is already set by Expect")
	}

	if mmRollbackReserve.defaultExpectation.paramPtrs == nil {
		mmRollbackReserve.defaultExpectation.paramPtrs = &StocksStorageMockRollbackReserveParamPtrs{}
	}
	mmRollbackReserve.defaultExpectation.paramPtrs.skus = &skus
	mmRollbackReserve.defaultExpectation.expectationOrigins.originSkus = minimock.CallerInfo(1)

	return mmRollbackReserve
}

// Inspect accepts an inspector function that has same arguments as the StocksStorage.RollbackReserve
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) Inspect(f func(ctx context.Context, skus map[uint32]uint32)) *mStocksStorageMockRollbackReserve {
	if mmRollbackReserve.mock.inspectFuncRollbackReserve != nil {
		mmRollbackReserve.mock.t.Fatalf("Inspect function is already set for StocksStorageMock.RollbackReserve")
	}

	mmRollbackReserve.mock.inspectFuncRollbackReserve = f

	return mmRollbackReserve
}

// Return sets up results that will be returned by StocksStorage.RollbackReserve
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) Return(err error) *StocksStorageMock {
	if mmRollbackReserve.mock.funcRollbackReserve != nil {
		mmRollbackReserve.mock.t.Fatalf("StocksStorageMock.RollbackReserve mock is already set by Set")
	}

	if mmRollbackReserve.defaultExpectation == nil {
		mmRollbackReserve.defaultExpectation = &StocksStorageMockRollbackReserveExpectation{mock: mmRollbackReserve.mock}
	}
	mmRollbackReserve.defaultExpectation.results = &StocksStorageMockRollbackReserveResults{err}
	mmRollbackReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRollbackReserve.mock
}

// Set uses given function f to mock the StocksStorage.RollbackReserve method
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) Set(f func(ctx context.Context, skus map[uint32]uint32) (err error)) *StocksStorageMock {
	if mmRollbackReserve.defaultExpectation != nil {
		mmRollbackReserve.mock.t.Fatalf("Default expectation is already set for the StocksStorage.RollbackReserve method")
	}

	if len(mmRollbackReserve.expectations) > 0 {
		mmRollbackReserve.mock.t.Fatalf("Some expectations are already set for the StocksStorage.RollbackReserve method")
	}

	mmRollbackReserve.mock.funcRollbackReserve = f
	mmRollbackReserve.mock.funcRollbackReserveOrigin = minimock.CallerInfo(1)
	return mmRollbackReserve.mock
}

// When sets expectation for the StocksStorage.RollbackReserve which will trigger the result defined by the following
// Then helper
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) When(ctx context.Context, skus map[uint32]uint32) *StocksStorageMockRollbackReserveExpectation {
	if mmRollbackReserve.mock.funcRollbackReserve != nil {
		mmRollbackReserve.mock.t.Fatalf("StocksStorageMock.RollbackReserve mock is already set by Set")
	}

	expectation := &StocksStorageMockRollbackReserveExpectation{
		mock:               mmRollbackReserve.mock,
		params:             &StocksStorageMockRollbackReserveParams{ctx, skus},
		expectationOrigins: StocksStorageMockRollbackReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRollbackReserve.expectations = append(mmRollbackReserve.expectations, expectation)
	return expectation
}

// Then sets up StocksStorage.RollbackReserve return parameters for the expectation previously defined by the When method
func (e *StocksStorageMockRollbackReserveExpectation) Then(err error) *StocksStorageMock {
	e.results = &StocksStorageMockRollbackReserveResults{err}
	return e.mock
}

// Times sets number of times StocksStorage.RollbackReserve should be invoked
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) Times(n uint64) *mStocksStorageMockRollbackReserve {
	if n == 0 {
		mmRollbackReserve.mock.t.Fatalf("Times of StocksStorageMock.RollbackReserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRollbackReserve.expectedInvocations, n)
	mmRollbackReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRollbackReserve
}

func (mmRollbackReserve *mStocksStorageMockRollbackReserve) invocationsDone() bool {
	if len(mmRollbackReserve.expectations) == 0 && mmRollbackReserve.defaultExpectation == nil && mmRollbackReserve.mock.funcRollbackReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRollbackReserve.mock.afterRollbackReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRollbackReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RollbackReserve implements mm_loms.StocksStorage
func (mmRollbackReserve *StocksStorageMock) RollbackReserve(ctx context.Context, skus map[uint32]uint32) (err error) {
	mm_atomic.AddUint64(&mmRollbackReserve.beforeRollbackReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmRollbackReserve.afterRollbackReserveCounter, 1)

	mmRollbackReserve.t.Helper()

	if mmRollbackReserve.inspectFuncRollbackReserve != nil {
		mmRollbackReserve.inspectFuncRollbackReserve(ctx, skus)
	}

	mm_params := StocksStorageMockRollbackReserveParams{ctx, skus}

	// Record call args
	mmRollbackReserve.RollbackReserveMock.mutex.Lock()
	mmRollbackReserve.RollbackReserveMock.callArgs = append(mmRollbackReserve.RollbackReserveMock.callArgs, &mm_params)
	mmRollbackReserve.RollbackReserveMock.mutex.Unlock()

	for _, e := range mmRollbackReserve.RollbackReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRollbackReserve.RollbackReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollbackReserve.RollbackReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmRollbackReserve.RollbackReserveMock.defaultExpectation.params
		mm_want_ptrs := mmRollbackReserve.RollbackReserveMock.defaultExpectation.paramPtrs

		mm_got := StocksStorageMockRollbackReserveParams{ctx, skus}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRollbackReserve.t.Errorf("StocksStorageMock.RollbackReserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRollbackReserve.RollbackReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.skus != nil && !minimock.Equal(*mm_want_ptrs.skus, mm_got.skus) {
				mmRollbackReserve.t.Errorf("StocksStorageMock.RollbackReserve got unexpected parameter skus, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRollbackReserve.RollbackReserveMock.defaultExpectation.expectationOrigins.originSkus, *mm_want_ptrs.skus, mm_got.skus, minimock.Diff(*mm_want_ptrs.skus, mm_got.skus))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRollbackReserve.t.Errorf("StocksStorageMock.RollbackReserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRollbackReserve.RollbackReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRollbackReserve.RollbackReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmRollbackReserve.t.Fatal("No results are set for the StocksStorageMock.RollbackReserve")
		}
		return (*mm_results).err
	}
	if mmRollbackReserve.funcRollbackReserve != nil {
		return mmRollbackReserve.funcRollbackReserve(ctx, skus)
	}
	mmRollbackReserve.t.Fatalf("Unexpected call to StocksStorageMock.RollbackReserve. %v %v", ctx, skus)
	return
}

// RollbackReserveAfterCounter returns a count of finished StocksStorageMock.RollbackReserve invocations
func (mmRollbackReserve *StocksStorageMock) RollbackReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollbackReserve.afterRollbackReserveCounter)
}

// RollbackReserveBeforeCounter returns a count of StocksStorageMock.RollbackReserve invocations
func (mmRollbackReserve *StocksStorageMock) RollbackReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollbackReserve.beforeRollbackReserveCounter)
}

// Calls returns a list of arguments used in each call to StocksStorageMock.RollbackReserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRollbackReserve *mStocksStorageMockRollbackReserve) Calls() []*StocksStorageMockRollbackReserveParams {
	mmRollbackReserve.mutex.RLock()

	argCopy := make([]*StocksStorageMockRollbackReserveParams, len(mmRollbackReserve.callArgs))
	copy(argCopy, mmRollbackReserve.callArgs)

	mmRollbackReserve.mutex.RUnlock()

	return argCopy
}

// MinimockRollbackReserveDone returns true if the count of the RollbackReserve invocations corresponds
// the number of defined expectations
func (m *StocksStorageMock) MinimockRollbackReserveDone() bool {
	if m.RollbackReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RollbackReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RollbackReserveMock.invocationsDone()
}

// MinimockRollbackReserveInspect logs each unmet expectation
func (m *StocksStorageMock) MinimockRollbackReserveInspect() {
	for _, e := range m.RollbackReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksStorageMock.RollbackReserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRollbackReserveCounter := mm_atomic.LoadUint64(&m.afterRollbackReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackReserveMock.defaultExpectation != nil && afterRollbackReserveCounter < 1 {
		if m.RollbackReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StocksStorageMock.RollbackReserve at\n%s", m.RollbackReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StocksStorageMock.RollbackReserve at\n%s with params: %#v", m.RollbackReserveMock.defaultExpectation.expectationOrigins.origin, *m.RollbackReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollbackReserve != nil && afterRollbackReserveCounter < 1 {
		m.t.Errorf("Expected call to StocksStorageMock.RollbackReserve at\n%s", m.funcRollbackReserveOrigin)
	}

	if !m.RollbackReserveMock.invocationsDone() && afterRollbackReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksStorageMock.RollbackReserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RollbackReserveMock.expectedInvocations), m.RollbackReserveMock.expectedInvocationsOrigin, afterRollbackReserveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StocksStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetBySKUInspect()

			m.MinimockReserveInspect()

			m.MinimockReserveCancelInspect()

			m.MinimockReserveRemoveInspect()

			m.MinimockRollbackReserveInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StocksStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StocksStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetBySKUDone() &&
		m.MinimockReserveDone() &&
		m.MinimockReserveCancelDone() &&
		m.MinimockReserveRemoveDone() &&
		m.MinimockRollbackReserveDone()
}
